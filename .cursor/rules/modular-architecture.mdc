---
description: 
globs: 
alwaysApply: true
---
# üèóÔ∏è Modular by Feature Architecture

## Project Structure Overview

The project follows a feature-based modular architecture where each business domain is self-contained with its own components, hooks, stores, and types. This approach promotes maintainability, scalability, and clear separation of concerns.

### Core Directory Structure

**Features Directory**: Each business domain has its own feature folder containing all related code
- `auth/` - Authentication and authorization logic
- `admin/` - Administrative functionality and user management
- `user/` - User-specific features and dashboard
- `analytics/` - Data visualization and metrics

**Shared Directory**: Reusable components and utilities used across features
- `components/` - Common UI components (Button, Card, Input, etc.)
- `hooks/` - Shared custom hooks
- `utils/` - Utility functions and helpers
- `types/` - Shared TypeScript interfaces

**Stores Directory**: State management organized by domain
- `admin/` - Admin-specific stores (user management, analytics)
- `shared/` - Global stores (auth, layout)
- `user/` - User-specific stores

**Layouts Directory**: Page layout components
- `MainLayout.tsx` - Main application layout
- `Sidebar.tsx` - Navigation sidebar
- `TopBar.tsx` - Top navigation bar

## üì¶ Technology Stack

### State Management: Zustand
- Lightweight and simple state management
- Domain-specific stores for focused state
- Avoids prop drilling and complex state hierarchies
- Easy integration with React components

### Data Fetching: TanStack Query
- Server state management with caching
- Optimistic updates for better UX
- Automatic background refetching
- Error handling and loading states

### Routing: React Router
- Declarative routing with nested routes
- Route-based code splitting
- Protected routes with role-based access
- Clean URL structure

### Styling: Tailwind CSS
- Utility-first approach for rapid development
- Consistent design system
- Responsive design built-in
- Custom component styling

## üîß Architecture Principles

### Feature-Based Organization
Each feature is self-contained with its own components, hooks, stores, and types. This prevents cross-feature dependencies and makes the codebase more maintainable.

### Colocated Logic
Related code is kept together within the same feature directory. Components, their associated hooks, and types are located in the same folder for easy navigation and understanding.

### Lightweight Tooling
The stack is intentionally lightweight to avoid over-engineering. Simple tools are used until complexity requires more sophisticated solutions.

### Avoid State Drilling
Zustand stores are used for shared state instead of passing props through multiple component levels. This keeps components focused and reduces coupling.

## üéØ Key Benefits

### Maintainability
- Clear separation of concerns
- Easy to locate and modify feature-specific code
- Reduced cognitive load when working on specific features

### Scalability
- New features can be added without affecting existing code
- Independent development of features
- Clear boundaries between different parts of the application

### Developer Experience
- Fast feedback loops with HMR
- TypeScript for better DX and type safety
- Consistent patterns across features
- Easy onboarding for new developers

### Performance
- Code splitting by feature
- Optimized bundle sizes
- Efficient state management
- Minimal re-renders

## üö´ Anti-Patterns to Avoid

### State Drilling
Avoid passing state through multiple component levels. Use Zustand stores for shared state instead.

### Monolithic Components
Keep components small and focused on a single responsibility. Break down large components into smaller, reusable pieces.

### Mixed Concerns
Don't mix UI logic with business logic. Keep components focused on presentation and use hooks for business logic.

### Over-Engineering
Don't add complexity before it's needed. Start simple and scale gradually as requirements grow.

### Custom Routing
Use React Router instead of building custom routing solutions. Leverage the framework's capabilities.

## üìö Best Practices

### Start Simple
Begin with React state for local component state. Add Zustand only when you need shared state across components.

### Type Safety
Use TypeScript for better developer experience and catch errors early. Create branded types for domain-specific values.

### Performance Optimization
Use React.memo for expensive components, implement useCallback/useMemo for expensive computations, and leverage code splitting.

### Testing Strategy
Test critical business logic, use React Testing Library for component tests, and test Zustand stores in isolation.

## üîÑ Migration Path

1. Organize existing code into feature-based folders
2. Move shared components to the shared directory
3. Implement Zustand stores for global state
4. Add React Router for proper routing
5. Integrate TanStack Query for data fetching
6. Optimize with code splitting
7. Add comprehensive TypeScript types

## üéØ Success Metrics

- Reduced time to implement new features
- Decreased bug frequency due to clear boundaries
- Improved developer onboarding experience
- Better code maintainability scores
- Faster build and development times
